\section{How the Devices Are Placed}
\label{sec:positioning}

The first time that the user visits the page in a new browser, the system has
to place the devices in the screen. Since the number and type of devices are
different for each user, an algorithm must be used to placed the devices in
the available space.

\subsection{Simplified Algorithm}

The restrictions that we have to comply are:

\begin{itemize}
  \item We have an undetermined number of elements to place.
  \item For the sake of simplicity, the elements and the canvas are
  rectangular.
  \item Every element, including the canvas, has a different size.
  \item We have to place them in the most comfortable way possible, ideally
  using all the space we have.
\end{itemize}

The solution to the above problem is known as a variant of 2-D rectangle
packing and it is, regrettably, NP-hard. At this point, it is clear that we
need a simplification. Furthermore, the original problem also presents a big
issue, as it does not address an important constraint: the possibility of
resizing the elements to fit the canvas.

A simplified algorithm is proposed and implemented, relaxing some terms while obtaining acceptable results. The important concepts are:

\begin{itemize}
  \item The main goal is to draw a virtual grid of M$\times$N cells (like a table). Every cell can be a position for a device.
  \item Indeed, we are going to calculate the smallest grid of M$\times$N cells in which the devices can be placed.
  \item Finally, we are going to resize the elements to fit within that cell, giving that every cell has the same size.
\end{itemize}

To obtain the squared grid for N elements, we simply have to calculate the ceiling of the squared root of N as seen in \eqref{gridx}.

\begin{equation}
  Grid_{x} = \lceil\sqrt{N}\rceil \label{gridx}
\end{equation}

This formula synthesizes the idea that, given a certain number of elements N:

\begin{itemize}
  \item If N is a square number (that is, it exists an integer $x$ that
  fulfills $x^2 = N$), then you could fit a whole grid of $x\times{}x$ with
  N elements.
  \item Otherwise, this integer N must be between the square of two
  consecutive integers, that we are going to call $x$ and $x+1$. That is,
  $x^2 < N$ and $(x+1)^2 > N$. In visual words, that means that a grid of
  size $x$ cannot hold that number of elements, and a grid of size $x+1$ can
  hold that number of elements but there will be empty \emph{cells}.
  \item In that case, we choose the grid of size $x+1$, this way we want to
  apply the ceiling function to the squared root to obtain the next following
  integer.
\end{itemize}

In the following figures we can appreciate what all of this means with real examples, using different number of elements.

(insert images with the disposition of different number of elements in the
grid)

If we look at the examples below, we can guess an improvement without making
the calculation severely complicate. We can see that, at certain points, a
whole row of the grid is completely empty, so we are wasting vertical space.
In theory, we could detect when this happens and try to reduce the vertical
height of the grid by one, effectively converting this squared grid into a
rectangle grid with different number of columns and rows.

Parting from an example: if we have $N = 19$, then we obtain $x = 5$ by
applying the previous formula. This will lead us to a 5x5 grid, but the last
row will be completely empty. The question that we have to ask ourselves is:
how big has to be the rectangle grid in order to be able to place this number
of elements? Briefly, the answer is $x \cdot (x - 1)$. That is a mathematical
way of describing that we are decreasing the number of rows by one. In this
case, we need a grid of $5 \times 4$ elements: that will hold up to 20
elements.

To discover whether we have to decrease the number of columns or not, we must
compare that number $(x \cdot x - 1)$ with the actual count of elements. If we
know that this number is bigger or equals to the number of elements, then we
know that a grid of $x \cdot (x - 1)$ elements can hold those elements. On the
contrary, if we know that this number is strictly lower than the number of
elements, then we know that a grid of $x \cdot x$ is unavoidable. This can be
formulated this way:

\begin{equation}
  Grid_{y} = 
  \begin{cases}
    Grid_{x} - 1 & \text{if } N \leq Grid_{x} \cdot (Grid_{x} - 1),\\
    Grid_{x} & \text{if } N > Grid_{x} \cdot (Grid_{x} - 1).
  \end{cases} \label{gridy}
\end{equation}

Another question appears: Do we need to shrink the grid only by one?
Is there any case in which we have to shrink the grid by two or more?

The answer is no.

We can prove why not by calculating if a grid of $(x - 1) \cdot (x - 1)$
elements can hold more elements that the grid of $x \cdot (x - 2)$.
If that is the case, then we would not need to shrink the grid in any case by
two because the grid will be already horizontally shorter.
It is quick to prove this is true following the steps explained from
\eqref{xdem1} to \eqref{xdem3}.

\begin{eqnarray}
  (x-1) \cdot (x-1) &<& x \cdot (x-1) \label{xdem1} \\
  x^2-2x+1 &<& x^2-2x \label{xdem2} \\
  1 &<& 0 \label{xdem3}
\end{eqnarray}

Then, using this final algorithm, the previous examples will change:

(insert images with the disposition of different number of elements in the grid using the final algorithm)

Using this algorithm we can calculate the height, width, vertical and
horizontal offset for every element. If we want to work with percentages, we
only have to divide the size of the container between the number of columns
and rows. For example, if we want to fill the container at 100\%, then every
element will be of size $100/x \times 100/y$. The actual values
for the offset needed for every particular element is then easy to calculate
if we fill the canvas one by one.

\subsection{Storage Positioning}

Next time an user visits this page, the system will remember the last position
of those elements instead of calculating the grid again. Because the user can
change the size of the window at any time, we cannot relay on fixed
positioning with pixels, because our canvas could be bigger or, worse, smaller
than the one we have calculated. Besides being not very elegant, we can find
several situations where the page is unusable.

The best way to avoid all that trouble is treating every position or size in
terms of percentages. This is how is done in the code, and it allows the user
to resize the window at any time: the devices will be resized dinamically
according to that window size.

To store and retrieve painlessly these values, we are going to take advantage
of an useful \idx{MooTools} class: \idc{Hash.Cookie} \cite{MooHashCookie}.
With this utility, we only have to specify the name for the \idc{Cookie} and
we can store a \idc{Hash} into a \idc{Cookie} without worrying about the
\idc{Cookie} itself.
Besides loading the data of the \idc{Cookie} directly on the \idc{Hash} at its
creation, if we change a value of the \idc{Hash} it will be automatically
updated in the \idc{Cookie}.

The reason for using a \idc{Cookie} is mostly because it reduces complexity on
the server, since it does not have to store the position of every device.
Other good reason is that it is the most simple way of allowing different
arrangements in different places; for example the user may want to arrange
radically different its devices in a big screen like in a TV or on a smaller
screen like in a netbook. Finally, it is universal as it is supported by
almost every browser.

The final decision is to have one \idc{Cookie} for each device.
This is very straightforward for the implementation, since a \idc{Cookie} can
have the name of the container.
Each \idc{Hash} that is stored in every \idc{Cookie} is composed by the four
values needed for positioning the element: \idc{offsetX}, \idc{offsetY},
\idc{width} and \idc{height}.
These values are percentages respect the container (the devices list) and an
\idc{Hash} example is presented in Listing~\ref{cookiehash}.

\begin{lstlisting}[language=JavaScript,label=cookiehash,
  caption=Cookie Hash example]
{
  offsetX: 15,
  offsetY: 50,
  height: 10,
  width: 20
}
\end{lstlisting}

Then, each time the object size or dimension changes, the \idc{Hash} (and
therefore the \idc{Cookie}) is updated. These changes happen mostly in two
situations: when we resize a device (changing its size but no its position) or
when we move around a device (changing its position but not its size).
